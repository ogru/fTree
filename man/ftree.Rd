% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{ftree}
\alias{ftree}
\title{Fits a regression tree to functional and multivariate output data}
\usage{
ftree(.X = NULL, .Y = NULL, .D = NULL, .SIGMA_inv = NULL,
  cost.type = "sse", tree.type = "single", nP = if (tree.type ==
  "randomforest") round((ncol(.X)/3)) else ncol(.X), nBoot = 1000,
  .minSplit = 20, .minBucket = round(.minSplit/3), .cp = 0.005,
  ArgStep = 1, verbose = TRUE, parallel = TRUE, .predictorType = rep(0,
  ncol(.X)))
}
\arguments{
\item{.X}{- An nxp matrix of covariates}

\item{.Y}{- A matrix of functions stacked in columns. Assumes that all functions were evaluated on the same time temporal grid.
You can also pass multiple such matrices stacked in a list. This option is allowed only in the case of distance
based cost functions (\code{wss, rdist}).}

\item{.D}{- Optional distance matrix for wss/rdist cost function}

\item{cost.type}{- Cost function type. It can be any of the following: "sse", "mahalanobis", "wss", "l2norm", "rdist", "l2square" (see the details).}

\item{tree.type}{- What type of tree based predictor you want to fit. Currently supported: single tree, random forest, bagging}

\item{nP}{- The number of predictors to consider on each attempted split. Active only for tree.type = "randomforest"}

\item{nBoot}{- The number of trees to consider in bootstrapping}

\item{.minSplit}{- minimum required number of elements in a node in order to attempt a split.}

\item{.minBucket}{- minimum number of elements in leaf nodes. Defaults to .minSplit/3.}

\item{.cp}{- complexity parameter, split is accepted if it provides imporovement that is at least cp*rootGoodness}

\item{verbose}{- print progres (default = TRUE)}

\item{.predictorType}{- A boolean vector of length \code{ncol(.X)} specifying the types of predictors (0 - Continuous, 1 - Categorical). It defaults to \code{all = 0}.}
}
\details{
This code implements various functional and multivariate tree splitting routines.
         See the vignette for a detailed description of each cost function and for a tutorial on how to use the code.
         Note that this is a research code, hence it has more cost functions than we would normally ship within a release version.
         The \code{'sse'} and \code{'wss'} cost functions are completely experimental, use them at your own responsibility.

         When using \code{'rdist'} there are two modeling paths you can take. The first path is to provide a distance type through
         variable \code{.D} (i.e. \code{.D = 'euclidean'}). The distances are computed internally with the generic \code{dist} function.  The provided distance type
         must match one of the options available for variable \code{method} in \code{dist()} (see \code{help(dist)}).
         If you are using a distance that cannot be computed with the \code{dist} function then you are allowed to provide a pre-computed
         distance matrix by assigning it to the input variable \code{.D} (i.e. \code{.D = <my_dist_matrix>}).
}
\author{
Ognjen Grujic (\email{ognjengr@gmail.com})
}
