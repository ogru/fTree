{
    "collab_server" : "",
    "contents" : "#' @useDynLib fTree\n#' @importFrom Rcpp sourceCpp\n#'\n#' @title Fits a regression tree to functional data\n#'\n#' @param .X - An nxp matrix of covariates\n#' @param .Y - A matrix of functions stacked in columns. Assumes that all functions were evaluated on the same time grid\n#' @param .D - Optional distance matrix for wss/rdist cost function\n#' @param cost.type  - Cost function type. It can be any of the following: \"sse\", \"mahalanobis\", \"wss\", \"l2norm\", \"rdist\", \"l2square\" (see the details).\n#' @param tree.type  - What type of tree based predictor you want to fit. Currently supported: single tree, random forest, bagging\n#' @param nP - The number of predictors to consider on each attempted split. Active only for tree.type = \"randomforest\"\n#' @param nBoot - The number of trees to consider in bootstrapping\n#' @param .minSplit - minimum required number of elements in a node in order to attempt a split.\n#' @param .minBucket - minimum number of elements in leaf nodes. Defaults to .minSplit/3.\n#' @param .cp - complexity parameter, split is accepted if it provides imporovement that is at least cp*rootGoodness\n#' @param verbose - print progres (default = TRUE)\n#'\n#' @details This code implements various functional and multivariate tree splitting routines.\n#'          See the vignette for a detailed description of each cost function and for a tutorial on how to use the code.\n#'          Note that this is a research code, hence it has more cost functions than we would normally ship within a release version.\n#'          The \\code{'sse'} and \\code{'wss'} cost functions are completely experimental, use them at your own responsibility. Also note that\n#'          'mahalanobis' cost function takes a while to compute when using bootstrapped trees. Our recommendation is to use it only\n#'          in the case of \\code{tree.type='single tree'}. The fastest to compute cost function is \\code{'rdist'}.\n#'\n#'          When using \\code{'rdist'} there are two modeling paths you can take. The first path is to provide a distance type through\n#'          variable \\code{.D} (i.e. \\code{.D = 'euclidean'}). The distances are computed internally with the generic \\code{dist} function.  The provided distance type\n#'          must to match one of the options available for variable \\code{method} in \\code{dist()} (see \\code{help(dist)}).\n#'          If you are using a distance that cannot be computed with the \\code{dist} function then you are allowed to provide a pre-computed\n#'          distance matrix by assigning it to the input variable \\code{.D} (i.e. \\code{.D = <my_dist_matrix>}).\n#'\n#' @author Ognjen Grujic (\\email{ogyg@stanford.edu} or \\email{ognjengr@gmail.com})\n#'\n#' @export\n#'\nftree <- function(.X = NULL, .Y = NULL, .D = NULL, .SIGMA_inv = NULL, cost.type = 'sse',\n                  tree.type = \"single\", nP = if(tree.type == \"randomforest\") round((ncol(.X)/3))\n                  else ncol(.X), nBoot = 1000,\n                  .minSplit = 20, .minBucket = round(.minSplit/3), .cp = 0.005, ArgStep = 1,\n                  verbose = TRUE, parallel = TRUE) {\n\n  require(foreach)\n  require(doParallel)\n\n  cost.type <- match.arg(cost.type, c(\"sse\", \"mahalanobis\", \"wss\", \"l2norm\", \"rdist\", \"l2square\"))\n  tree.type <- match.arg(tree.type, c(\"single\", \"randomforest\", \"bagging\"))\n\n  if(is.null(.X)) stop('Covariates were not provided!')\n\n  .X = as.matrix(.X)\n\n  if(cost.type == \"wss\" | cost.type == \"rdist\"){\n\n    if(is.null(.D)) {\n      stop('For cost type WSS you MUST provide a distance matrix or distance type (i.e. \"euclidean\"). ')\n    } else if(is.character(.D)){\n      if(is.null(.Y)) {\n        stop('Functions were not provided! Please provide functions and distance type or just a distance matrix.')\n      } else {\n        .D <- as.matrix(dist(as.matrix(t(.Y)), method = .D))\n        .SIGMA_inv = matrix(NA, 2, 2)\n      }\n    } else if(is.matrix(.D)){\n      .SIGMA_inv = matrix(NA,2,2)\n    } else {\n      stop('.D is not a matrix nor a string. Exiting!')\n    }\n\n    if(ncol(.D) != nrow(.X)) stop(\"The number of observations does not match the dimensions of the distance matrix.\")\n\n    .nObservations = ncol(.D)\n\n  } else { # sse, mahalanobis, l2norm\n\n    .Y = as.matrix(.Y)\n    .nObservations = ncol(.Y)\n\n    if(.nObservations != nrow(.X)) stop(\"The number of observations does not match the number of functions. Exiting!\")\n\n    if(cost.type == \"mahalanobis\"){\n      if(is.null(.SIGMA_inv)){\n        .SIGMA_inv <- solve(as.matrix(nearPD(cov(t(.Y)))$mat))\n        .D = matrix(NA, 2, 2)\n      } else {\n        if((nrow(.Y) != ncol(SIGMA_inv))) {\n          stop('nrow/ncol(SIGMA_inv) is not the same as ncol(.Y). Exiting!')\n        } else {\n          .SIGMA_inv = as.matrix(.SIGMA_inv)\n          .D = matrix(NA, 2, 2)\n        }\n      }\n    } else {\n      .SIGMA_inv = matrix(NA, 2, 2)\n      .D <- .SIGMA_inv\n    }\n  }\n\n  if(tree.type != \"single\") { # bagging, random forest....\n    if(nP > ncol(.X)) {\n      stop(\"nP cannot be larger than the number of covariates in .X.\n           Random forest gives the best result for: nP = sqrt(ncol(.X))\")\n    }\n    } else {\n      nP = ncol(.X)\n  }\n\n  out <- list()\n  out[['covariates']] <- .X\n  out[['functions']]  <- .Y\n  out[['costType']]   <- cost.type\n  out[['treeType']]   <- tree.type\n  out[['minSplit']]   <- .minSplit\n  out[['minBucket']]  <- .minBucket\n  out[['cP']]         <- .cp\n\n  .cType = switch(cost.type,\n                 \"sse\"         = 1,\n                 \"mahalanobis\" = 2,\n                 \"l2norm\"      = 3,\n                 \"wss\"         = 4,\n                 \"rdist\"       = 5,\n                 \"l2square\"    = 6)\n\n  if(tree.type==\"single\"){\n\n    loadVars(.X, .Y, .SIGMA_inv, .D, nP, .cType, .minSplit, .minBucket, .cp, ArgStep)\n\n    .INDEX = seq(1, nrow(.X) - 1)\n    .cGood         <- fTree:::computeGoodness(.INDEX)\n    out[['trees']][[1]] <- fTree:::fTreeRPart(.INDEX, .cGood, 0)\n\n    unloadVars();\n\n  } else {\n\n    .BOOTINDEX <- matrix(sample(nrow(.X), nrow(.X) * nBoot, replace=TRUE),\n                         ncol = nrow(.X), nrow=nBoot)\n\n    if(parallel){\n\n      .no_cores <- detectCores() - 1\n      cl <- makeCluster(.no_cores)\n      registerDoParallel(cl)\n\n      .bootList   <- matToList(.BOOTINDEX, .no_cores)\n\n      out[['trees']] <- Reduce(\"c\", foreach(i = 1:length(.bootList)) %dopar% {\n        loadVars(.X, .Y, .SIGMA_inv, .D, nP, .cType, .minSplit, .minBucket, .cp)\n        output <- fTreeBootstrap(.bootList[[i]] - 1)\n        unloadVars();\n        return(output)\n      })\n\n      stopCluster(cl)\n\n    } else{ # single core mode.\n\n      loadVars(.X, .Y, .SIGMA_inv, .D, nP, .cType, .minSplit, .minBucket, .cp)\n      out[['trees']] <- fTree:::fTreeBootstrap(.BOOTINDEX - 1)\n      unloadVars();\n\n    }\n  }\n\n  # Save the structure:\n  class(out) <- c('fTree', \"list\")\n  return(out);\n\n}\n\n#' @title A helper function for parallel computing (not exported)\n#'\n#' @param .matrix - A matrix to split into list;\n#' @param .chunksize - A number of rows in each list element;\n#'\n#' @details This code simply splits the rows of \\code{.matrix} into a list where each element of the list\n#'          contains \\code{.chunksize} number of rows of the input matrix. If \\code{.chunksize > nrow(.matrix)} the code\n#'          will return a list with one element, the \\code{.matrix} itself.\n#'\n#' @author Ognjen Grujic (\\email{ognjengr@gmail.com})\n#'\nmatToList <- function(.matrix, .chunksize){\n\n  if(.chunksize >= nrow(.matrix)){\n    outList = list(indices=.matrix)\n  } else {\n    outList <- vector('list', ceiling(nrow(.matrix)/.chunksize))\n    for(i in 1:length(outList)){\n      if(nrow(.matrix) < .chunksize){\n        outList[[i]] <- .matrix\n      } else {\n        outList[[i]] <- .matrix[1:.chunksize,]\n        .matrix <- .matrix[-c(1:.chunksize), , drop=FALSE]\n      }\n    }\n  }\n  return(outList)\n\n}\n\n#' @title Extracts node data into a data frame\n#'\n#' @param .tree - an \"fTree\" object\n#' @param .index - index of the tree you wish to process\n#' @param .round - The number of rounding digits\n#'\n#' @author Ognjen Grujic (\\email{ognjengr@gmail.com})\n#'\n#' @export\n#'\nextractNodeData <- function(.tree, .index, .node = NULL, .round=NULL){\n\n  if(is.null(.tree)) stop('fTree object was not provided. Exiting!')\n  if(class(.tree)[1] != 'fTree') stop(\"Passed object is not of class 'fTree'. Exiting!\")\n\n  .segments = data.frame(xStart    = numeric(),\n                         xEnd      = numeric(),\n                         yStart    = numeric(),\n                         yEnd      = numeric(),\n                         predictor = character(),\n                         value     = character(),\n                         position  = character(),\n                         left      = character(),\n                         right     = character(),\n                         colour    = character())\n\n  .segments <-    data.frame(xStart   = .tree$trees[[.index]]$midpoint,\n                                xEnd     = .tree$trees[[.index]]$midpoint,\n                                yStart   = -0.5,\n                                yEnd     = 0,\n                                predictor= NA,\n                                value    = NA,\n                                position = \"0\",\n                                left     = NA,\n                                right    = NA,\n                                colour   = \"black\")\n\n  .extractNode <- function(.NODE, .nLeftLeaves, .position){\n\n    if(.NODE$isLeaf == 0){\n\n      # Color:\n      if(!is.null(.node) && (nchar(.position)) >= nchar(.node)){\n\n        cp = substr(.position, 1, nchar(.node))\n        lr = substr(.position, nchar(.node) + 1, nchar(.node) + 1)\n\n        if(.node == cp){\n\n          if(nchar(.position) == nchar(.node)){\n            colour = c(\"red\",\"blue\")\n          } else {\n            if(lr == \"r\"){\n              colour = c(\"blue\", \"blue\")\n            } else {\n              colour = c(\"red\", \"red\")\n            }\n          }\n        } else {\n          colour = c(\"black\", \"black\")\n        }\n\n      } else {\n        colour = c(\"black\", \"black\")\n      }\n\n\n      # Horizontal Line:\n      horizontals = data.frame(xStart    = rep(.NODE$midpoint + .nLeftLeaves, 2),\n                               xEnd      = c(.NODE$left$midpoint + .nLeftLeaves,\n                                             .NODE$left$nLeaves   + .nLeftLeaves + .NODE$right$midpoint),\n                               yStart    = rep(.NODE$depth, 2),\n                               yEnd      = rep(.NODE$depth, 2),\n                               predictor = c(.NODE$bestPredictor + 1, NA),\n                               value     = c(.NODE$splitPoint, NA),\n                               position  = rep(.position, 2),\n                               left      = NA,\n                               right     = NA,\n                               colour    = colour,\n                               stringsAsFactors = FALSE)\n\n      horizontals$left[1]  <- paste(.NODE$left$indices, collapse=\",\")\n      horizontals$right[1] <- paste(.NODE$right$indices, collapse=\",\")\n\n      # Vertical Lines:\n      verticals  = data.frame(xStart   = c(.NODE$left$midpoint + .nLeftLeaves,\n                                           .NODE$left$nLeaves  + .nLeftLeaves + .NODE$right$midpoint),\n                              xEnd     = c(.NODE$left$midpoint + .nLeftLeaves,\n                                           .NODE$left$nLeaves  + .nLeftLeaves + .NODE$right$midpoint),\n                              yStart   = rep(.NODE$depth, 2),\n                              yEnd     = rep(.NODE$depth + 1, 2),\n                              predictor= NA,\n                              value    = NA,\n                              position = c(paste(.position, \"l\", sep=\"\"),\n                                           paste(.position, \"r\", sep=\"\")),\n                              left     = NA,\n                              right    = NA,\n                              colour   = colour)\n\n      .segments <<- rbind(.segments, horizontals, verticals)\n\n      # Continue calling:\n      .extractNode(.NODE$left,  .nLeftLeaves                     , paste(.position, \"l\", sep=\"\"))\n      .extractNode(.NODE$right, .nLeftLeaves + .NODE$left$nLeaves, paste(.position, \"r\", sep=\"\"))\n    }\n  }\n\n  .extractNode(.tree$trees[[.index]], 0, \"0\")\n\n  if(is.null(.round)){\n    .labels <- .segments$value\n  } else {\n    .labels <- round(as.double(.segments$value),.round)\n  }\n  .segments$label <- paste(colnames(.tree$covariates)[.segments$predictor], .labels, sep=\" > \")\n  .segments$label[is.na(.segments$predictor)] <- NA\n  .segments$colour = factor(.segments$colour, levels=c(\"black\",\"red\",\"blue\"))\n  return(.segments)\n\n}\n\n#' @title Plots a (functional) regression tree\n#'\n#' @param .object - An \\code{fTree} object or \\code{.segments} object produced with \\code{extractNodeData}\n#' @param .index - Index of the tree you wish you plot (in the case of bootstrapped trees)\n#' @param .horizontal - Whether to plot the tree with horizontal orientation\n#' @param .lineWidth - The width of the tree lines\n#' @param .depth - Maximum plotting depth (useful for large trees)\n#' @param .labSize - The size of the node labels\n#' @param .labAng - The angle of node labels\n#' @param .ggReturn - Whether to return a \\code{ggplot} object or not.\n#' @param .ylimLow - Lower limit of y axis\n#' @param .ylimHigh - Higher limit of y axis\n#' @param .node - A node you wish to highlight. The node is specified as a path throught the tree from the root node.\n#'                Example: \\code{.node = '0llr'} = 0 - root, l - left, l - left, r - right.\n#'                The left side branches of the node will be painted in red, while the right side will be painted in blue.\n#' @param .round - The number of rounding digits for labels.\n#' @details This function relies on the \\code{extractNodeData} function and \\code{ggplot} plotting package.\n#'          The function outputs publication ready images of the passed tree.\n#'\n#' @author Ognjen Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\n#'\nplotFtree <- function(.object,\n                      .index = 1,\n                      .horizontal = FALSE,\n                      .lineWidth  = 1,\n                      .depth      = Inf,\n                      .labSize    = 1,\n                      .labAng     = 0,\n                      .ggReturn   = FALSE,\n                      .ylimLow    = 0,\n                      .ylimHigh   = NA,\n                      .node       = NULL,\n                      .round      = NULL\n) {\n\n  if(is.null(.object)) stop(\"Object was not provided! Exiting.\")\n\n  if(class(.object) == \"fTree\"){\n      if(.index > length(.object$trees)){\n        stop('Provided .index is larger than the number of trees in the structure.')\n      }\n     .segments <- extractNodeData(.object, .index, .node, .round=.round)\n  } else if(class(.object) == \"fTreeSegments\"){\n     .segments <- .object\n  } else {\n     stop(\"Provided object is not valid. Either provide an fTree object\n         or segments data frame produced with 'extractNode' function. Exiting!\")\n  }\n\n  ggBASE <- ggplot(data=subset(.segments, yStart < .depth)) +\n            geom_segment(aes(x=xStart, y=yStart, xend=xEnd, yend=yEnd, colour = colour), lwd = .lineWidth)  +\n            geom_label(aes(x=xStart, y=yStart - 0.05, label=label),\n               vjust=\"center\",\n               angle = .labAng, size = .labSize) +\n            scale_colour_manual(values=c(\"black\",\"red\",\"blue\")) + guides(colour=FALSE)\n\n  if(.horizontal) {\n    ggBASE <- ggBASE + ylim(.ylimLow, .ylimHigh) + xlab(NULL) + ylab(NULL) + coord_flip()\n  } else {\n    ggBASE <- ggBASE + scale_y_reverse(limits=c(8, -1.5)) + xlab(NULL) + ylab(NULL) + xlim(0, max(.segments$xEnd) + 1)\n  }\n\n  if(.ggReturn) {\n    return(ggBASE)\n  } else {\n    print(ggBASE)\n  }\n\n}\n\n\n#' @title Returns the indices of data points contained within a specific node\n#'\n#' @param .tree - An fTree object\n#' @param .node - The code of the node you wish to extract (i.e. \\code{.node=\"0lr\"})\n#'\n#' @details The \\code{.node} parameter should specify a path through the tree to\n#'          the node you wish to extract for example: root-left-right-left = \\code{.node='0lrl'}.\n#' @author Ognjen Grujic \\email{ogyg@stanford.edu}\n#'\n#' @export\n#'\ngetNodeIndices <- function(.tree, .node){\n\n  if(nchar(.node) == 1){\n    if(.tree$isLeaf == 1){\n      return(list(centerInd = .tree$indices + 1))\n    } else {\n      return(list(leftInd  = .tree$left$indices + 1,\n                  rightInd = .tree$right$indices + 1))\n    }\n  } else {\n\n    if(substr(.node, 2, 2) == \"r\"){\n      getNodeIndices(.tree$right, substr(.node,2, nchar(.node)))\n    } else {\n      getNodeIndices(.tree$left, substr(.node,2, nchar(.node)))\n    }\n  }\n}\n\n\n#' @title matrix to list\n#'\n#' @param .matrix  - A matrix you wish to divide into a list\n#' @param .chunksize - The number of rows of \\code{.matrix} to be contained in each\n#'                     element of the resulting list.\n#'\n#' @details This function simply splits the provided matrix into \\code{N} elements, each containing\n#'          \\code{.chunksize} of rows of the original matrix. The list elements are mutually exclusive.\n#'\n#' @author Ogy Grujic (\\email{ogyg@stanford.edu})\n#'\n#' @export\n#'\nmatToList <- function(.matrix, .chunksize){\n\n  if(.chunksize >= nrow(.matrix)){\n    outList = list(indices=.matrix)\n  } else {\n    outList <- vector('list', ceiling(nrow(.matrix)/.chunksize))\n    for(i in 1:length(outList)){\n      if(nrow(.matrix) < .chunksize){\n        outList[[i]] <- .matrix\n      } else {\n        outList[[i]] <- .matrix[1:.chunksize,]\n        .matrix <- .matrix[-c(1:.chunksize), , drop=FALSE]\n      }\n    }\n  }\n  return(outList)\n\n}\n\n#' @title Predict function for ftree\n#'\n#' @param ftreeObj - An object of class \\code{ftree} as produced by the \\code{ftree} function\n#' @param .Xnew    - A data frame with a new set of covariates for which to make a prediction(s).\n#'\n#' @details The code returns a list of length \\code{nrow(.Xnew)}. Each element of the list is a matrix whose\n#'          number of rows equals the number of the original argument values (discretizations) of the\n#'          functions contained in \\code{ftreeObj}, while the number of columns is equal to the number of\n#'          trees contained in the \\code{ftreeObj} (i.e. it's a vector for the \\code{'single'} mode ).\n#'          This function does not work with trees of type \\code{\"wss\"}.\n#'\n#' @author Ogy Grujic \\email{ognjengr@gmail.com}\n#'\n#' @export\n#'\npredictFtree <- function(ftreeObj = NULL, .Xnew = NULL){\n\n  if(is.null(ftreeObj) | class(ftreeObj)[1] != \"fTree\") stop('Ftree Object is irregular or not provided. Stopping!')\n  if(is.null(.Xnew)) stop(\"A new set of covariates was not provided. Stopping!\")\n  if(!is.data.frame((.Xnew))) stop(\".Xnew should be a data frame!\")\n\n  match.arg(ftreeObj$costType, c(\"mahalanobis\", \"sse\", \"l2norm\",\"rdist\",\"l2square\"))\n\n  # this should change to include a situation where Xnew has more than the number of covariates in ftreeObj.\n  # if that makes sense at all.\n  if(length(setdiff(colnames(ftreeObj$covariates), colnames(.Xnew))) > 0) {\n    stop(\"The covariates in Xnew don't match the covariates in ftreeObj!\")\n  }\n\n  # Makes a prediction of one single tree.\n  .treePred <- function(.node, .xnew){\n         if(.node$isLeaf == 1){\n\n           temp <- ftreeObj$functions[,(.node$indices + 1)]\n\n           if(is.null(ncol(temp))){\n             return(temp)\n           } else {\n             return(rowMeans(temp))\n           }\n           # if(is.null(nrow(ftreeObj$functions[,.node$indices]))) {\n           #    return(ftreeObj$functions[,(.node$indices + 1)])\n           # } else {\n           #    return(rowMeans(ftreeObj$functions[,(.node$indices + 1)]))\n           # }\n\n         } else {\n\n           # see if its right or left:\n           .predictor <- .node$bestPredictor + 1\n\n           if(length(grep(\",\", .node$splitPoint)) > 0){ # it's categorical:\n              # create a set out of .node$splitPoint\n              # check if category present in .xnew is inside the set.\n              # if yes then its left, if not then its right.\n\n           } else {\n             if(.xnew[.predictor] < as.numeric(.node$splitPoint)){\n\n                .treePred(.node$left, .xnew)\n\n             } else {\n\n                .treePred(.node$right, .xnew)\n\n             }\n           }\n         }\n  }\n\n  # computes predictions for each row of Xnew (if applicable).\n  # Xnew should be provided as a data frame even if only one row is provided.\n  .predictions <- apply(.Xnew, 1, function(x){\n    ldply(ftreeObj$trees, function(y){\n      .treePred(y, x)\n    })\n  })\n\n  # n_trees <- length(ftreeObj$trees)\n  # # .predictions <- vector(\"list\", nrow(.Xnew))\n  # .predictions <- apply(.Xnew, 1, function(x){\n  #                       .preds <- vector(\"list\", n_trees)\n  #                       for(j in 1:n_trees){\n  #                         .preds[[j]] <- .treePred(ftreeObj$trees[[j]], x)\n  #                       }\n  #                       return(.preds)\n  #                     })\n\n\n  return(.predictions)\n\n}\n\n\n#' @title Produces a sensitivity/importance plot\n#'\n#' @param ftreeObj - An object of class \"ftree\"\n#' @param mode     - Mode you wish to run (plot - just plots, ggRet - returns a ggplot structure, data - returns data)\n#'\n#' @details Simply computes sensitivities based on the reduction in the cost function (no permutation is performed ever).\n#'          For plotting, this code uses \\code{ggplot} graphics. If you wish to modify any part of the plot set \\code{mode=\"ggRet\"}, the code\n#'          will then return a \\code{ggplot} structure that you can modify. Refer to the \\code{ggplot} documentation for more details.\n#'\n#' @author Ogy Grujic (\\email{ognjengr@gmail.com})\n#'\n#' @export\n#'\nvarSensitivity <- function(ftreeObj = NULL, mode = \"plot\"){\n\n  if(is.null(ftreeObj)) stop(\"ftreeObject was not provided. Exiting!\")\n  if(class(ftreeObj)[1] != \"fTree\") stop('Passed object is not of class \"fTree\". Exiting!')\n\n  mode <- match.arg(mode, c(\"plot\", \"ggRet\", \"data\"))\n\n  .importance <- matrix(0, nrow = ncol(ftreeObj$covariates), ncol = length(ftreeObj$trees))\n  rownames(.importance)  <- colnames(ftreeObj$covariates)\n\n  .extractSensitivities <- function(.node) {\n    if(.node$isLeaf == 1) {\n      return\n    } else {\n      .importance[,i] <<- .importance[,i] + (.node$nodeGoodness - .node$splitsGoodness[1,])*(length(.node$indices)/nrow(ftreeObj$covariates))\n    }\n  }\n\n  for(i in 1:length(ftreeObj$trees)) {\n    .extractSensitivities(ftreeObj$trees[[i]])\n  }\n\n  .importance[is.nan(.importance)] <- 0\n\n  .ggDATA <- apply(.importance, 1, mean)\n  .ggDATA[.ggDATA < 0] <- 0         # modification!\n\n  .ggDATA <- .ggDATA/max(.ggDATA)\n  .ggDATA <- rev(sort(.ggDATA))\n\n  .ggDATA <- data.frame(parameter = names(.ggDATA), value=.ggDATA)\n  .ggDATA$rank <- factor(1:nrow(.ggDATA))\n  .ggDATA$parameter <- factor(.ggDATA$parameter, levels = rev(as.character(.ggDATA$parameter)))\n\n  .ggP <- ggplot(.ggDATA, aes(x= parameter, y=value, fill=rank)) +\n    geom_bar(stat = \"identity\", position = \"dodge\", lwd = 0.2, colour = \"black\") +\n    coord_flip() + guides(fill=FALSE) + ggtitle('Variable importance plot') + xlab('relative importance')\n\n  if(mode == \"plot\") {\n    print(.ggP)\n  } else if(mode == \"ggRet\") {\n    return(.ggP)\n  } else {\n    return(.ggDATA)\n  }\n\n}\n\n\n\n",
    "created" : 1510267445321.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "180|43|197|0|\n437|43|454|0|\n471|56|547|0|\n563|59|609|0|\n",
    "hash" : "32593344",
    "id" : "A25CA455",
    "lastKnownWriteTime" : 1510966064,
    "last_content_update" : 1510966064773,
    "path" : "~/Dropbox/TreesPaper/package/fTree/R/main.R",
    "project_path" : "R/main.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}